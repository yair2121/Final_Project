{"ast":null,"code":"'use strict';// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n/* eslint-disable space-unary-ops */var utils=require('../utils/common');/* Public constants ==========================================================*/ /* ===========================================================================*/ //var Z_FILTERED          = 1;\n//var Z_HUFFMAN_ONLY      = 2;\n//var Z_RLE               = 3;\nvar Z_FIXED=4;//var Z_DEFAULT_STRATEGY  = 0;\n/* Possible values of the data_type field (though see inflate()) */var Z_BINARY=0;var Z_TEXT=1;//var Z_ASCII             = 1; // = Z_TEXT\nvar Z_UNKNOWN=2;/*============================================================================*/function zero(buf){var len=buf.length;while(--len>=0){buf[len]=0;}}// From zutil.h\nvar STORED_BLOCK=0;var STATIC_TREES=1;var DYN_TREES=2;/* The three kinds of block type */var MIN_MATCH=3;var MAX_MATCH=258;/* The minimum and maximum match lengths */ // From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */var LENGTH_CODES=29;/* number of length codes, not counting the special END_BLOCK code */var LITERALS=256;/* number of literal bytes 0..255 */var L_CODES=LITERALS+1+LENGTH_CODES;/* number of Literal or Length codes, including the END_BLOCK code */var D_CODES=30;/* number of distance codes */var BL_CODES=19;/* number of codes used to transfer the bit lengths */var HEAP_SIZE=2*L_CODES+1;/* maximum heap size */var MAX_BITS=15;/* All codes must not exceed MAX_BITS bits */var Buf_size=16;/* size of bit buffer in bi_buf */ /* ===========================================================================\n * Constants\n */var MAX_BL_BITS=7;/* Bit length codes must not exceed MAX_BL_BITS bits */var END_BLOCK=256;/* end of block literal code */var REP_3_6=16;/* repeat previous bit length 3-6 times (2 bits of repeat count) */var REPZ_3_10=17;/* repeat a zero length 3-10 times  (3 bits of repeat count) */var REPZ_11_138=18;/* repeat a zero length 11-138 times  (7 bits of repeat count) */ /* eslint-disable comma-spacing,array-bracket-spacing */var extra_lbits=/* extra bits for each length code */[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];var extra_dbits=/* extra bits for each distance code */[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];var extra_blbits=/* extra bits for each bit length code */[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];var bl_order=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];/* eslint-enable comma-spacing,array-bracket-spacing */ /* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */ /* ===========================================================================\n * Local data. These are initialized only once.\n */ // We pre-fill arrays with 0 to avoid uninitialized gaps\nvar DIST_CODE_LEN=512;/* see definition of array dist_code below */ // !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\nvar static_ltree=new Array((L_CODES+2)*2);zero(static_ltree);/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */var static_dtree=new Array(D_CODES*2);zero(static_dtree);/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */var _dist_code=new Array(DIST_CODE_LEN);zero(_dist_code);/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */var _length_code=new Array(MAX_MATCH-MIN_MATCH+1);zero(_length_code);/* length code for each normalized match length (0 == MIN_MATCH) */var base_length=new Array(LENGTH_CODES);zero(base_length);/* First normalized length for each code (0 = MIN_MATCH) */var base_dist=new Array(D_CODES);zero(base_dist);/* First normalized distance for each code (0 = distance of 1) */function StaticTreeDesc(static_tree,extra_bits,extra_base,elems,max_length){this.static_tree=static_tree;/* static tree or NULL */this.extra_bits=extra_bits;/* extra bits for each code or NULL */this.extra_base=extra_base;/* base index for extra_bits */this.elems=elems;/* max number of elements in the tree */this.max_length=max_length;/* max bit length for the codes */ // show if `static_tree` has data or dummy - needed for monomorphic objects\nthis.has_stree=static_tree&&static_tree.length;}var static_l_desc;var static_d_desc;var static_bl_desc;function TreeDesc(dyn_tree,stat_desc){this.dyn_tree=dyn_tree;/* the dynamic tree */this.max_code=0;/* largest code with non zero frequency */this.stat_desc=stat_desc;/* the corresponding static tree */}function d_code(dist){return dist<256?_dist_code[dist]:_dist_code[256+(dist>>>7)];}/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */function put_short(s,w){//    put_byte(s, (uch)((w) & 0xff));\n//    put_byte(s, (uch)((ush)(w) >> 8));\ns.pending_buf[s.pending++]=w&0xff;s.pending_buf[s.pending++]=w>>>8&0xff;}/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */function send_bits(s,value,length){if(s.bi_valid>Buf_size-length){s.bi_buf|=value<<s.bi_valid&0xffff;put_short(s,s.bi_buf);s.bi_buf=value>>Buf_size-s.bi_valid;s.bi_valid+=length-Buf_size;}else{s.bi_buf|=value<<s.bi_valid&0xffff;s.bi_valid+=length;}}function send_code(s,c,tree){send_bits(s,tree[c*2]/*.Code*/,tree[c*2+1]/*.Len*/);}/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */function bi_reverse(code,len){var res=0;do{res|=code&1;code>>>=1;res<<=1;}while(--len>0);return res>>>1;}/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */function bi_flush(s){if(s.bi_valid===16){put_short(s,s.bi_buf);s.bi_buf=0;s.bi_valid=0;}else if(s.bi_valid>=8){s.pending_buf[s.pending++]=s.bi_buf&0xff;s.bi_buf>>=8;s.bi_valid-=8;}}/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */function gen_bitlen(s,desc)//    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n{var tree=desc.dyn_tree;var max_code=desc.max_code;var stree=desc.stat_desc.static_tree;var has_stree=desc.stat_desc.has_stree;var extra=desc.stat_desc.extra_bits;var base=desc.stat_desc.extra_base;var max_length=desc.stat_desc.max_length;var h;/* heap index */var n,m;/* iterate over the tree elements */var bits;/* bit length */var xbits;/* extra bits */var f;/* frequency */var overflow=0;/* number of elements with bit length too large */for(bits=0;bits<=MAX_BITS;bits++){s.bl_count[bits]=0;}/* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */tree[s.heap[s.heap_max]*2+1]/*.Len*/=0;/* root of the heap */for(h=s.heap_max+1;h<HEAP_SIZE;h++){n=s.heap[h];bits=tree[tree[n*2+1]/*.Dad*/*2+1]/*.Len*/+1;if(bits>max_length){bits=max_length;overflow++;}tree[n*2+1]/*.Len*/=bits;/* We overwrite tree[n].Dad which is no longer needed */if(n>max_code){continue;}/* not a leaf node */s.bl_count[bits]++;xbits=0;if(n>=base){xbits=extra[n-base];}f=tree[n*2]/*.Freq*/;s.opt_len+=f*(bits+xbits);if(has_stree){s.static_len+=f*(stree[n*2+1]/*.Len*/+xbits);}}if(overflow===0){return;}// Trace((stderr,\"\\nbit length overflow\\n\"));\n/* This happens for example on obj2 and pic of the Calgary corpus */ /* Find the first bit length which could increase: */do{bits=max_length-1;while(s.bl_count[bits]===0){bits--;}s.bl_count[bits]--;/* move one leaf down the tree */s.bl_count[bits+1]+=2;/* move one overflow item as its brother */s.bl_count[max_length]--;/* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */overflow-=2;}while(overflow>0);/* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */for(bits=max_length;bits!==0;bits--){n=s.bl_count[bits];while(n!==0){m=s.heap[--h];if(m>max_code){continue;}if(tree[m*2+1]/*.Len*/!==bits){// Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\ns.opt_len+=(bits-tree[m*2+1]/*.Len*/)*tree[m*2]/*.Freq*/;tree[m*2+1]/*.Len*/=bits;}n--;}}}/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */function gen_codes(tree,max_code,bl_count)//    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n{var next_code=new Array(MAX_BITS+1);/* next code value for each bit length */var code=0;/* running code value */var bits;/* bit index */var n;/* code index */ /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */for(bits=1;bits<=MAX_BITS;bits++){next_code[bits]=code=code+bl_count[bits-1]<<1;}/* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */ //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n//        \"inconsistent bit counts\");\n//Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\nfor(n=0;n<=max_code;n++){var len=tree[n*2+1]/*.Len*/;if(len===0){continue;}/* Now reverse the bits */tree[n*2]/*.Code*/=bi_reverse(next_code[len]++,len);//Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n//     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n}}/* ===========================================================================\n * Initialize the various 'constant' tables.\n */function tr_static_init(){var n;/* iterates over tree elements */var bits;/* bit counter */var length;/* length value */var code;/* code value */var dist;/* distance index */var bl_count=new Array(MAX_BITS+1);/* number of codes at each bit length for an optimal tree */ // do check in _tr_init()\n//if (static_init_done) return;\n/* For some embedded targets, global variables are not initialized: */ /*#ifdef NO_INIT_GLOBAL_POINTERS\n  static_l_desc.static_tree = static_ltree;\n  static_l_desc.extra_bits = extra_lbits;\n  static_d_desc.static_tree = static_dtree;\n  static_d_desc.extra_bits = extra_dbits;\n  static_bl_desc.extra_bits = extra_blbits;\n#endif*/ /* Initialize the mapping length (0..255) -> length code (0..28) */length=0;for(code=0;code<LENGTH_CODES-1;code++){base_length[code]=length;for(n=0;n<1<<extra_lbits[code];n++){_length_code[length++]=code;}}//Assert (length == 256, \"tr_static_init: length != 256\");\n/* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */_length_code[length-1]=code;/* Initialize the mapping dist (0..32K) -> dist code (0..29) */dist=0;for(code=0;code<16;code++){base_dist[code]=dist;for(n=0;n<1<<extra_dbits[code];n++){_dist_code[dist++]=code;}}//Assert (dist == 256, \"tr_static_init: dist != 256\");\ndist>>=7;/* from now on, all distances are divided by 128 */for(;code<D_CODES;code++){base_dist[code]=dist<<7;for(n=0;n<1<<extra_dbits[code]-7;n++){_dist_code[256+dist++]=code;}}//Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n/* Construct the codes of the static literal tree */for(bits=0;bits<=MAX_BITS;bits++){bl_count[bits]=0;}n=0;while(n<=143){static_ltree[n*2+1]/*.Len*/=8;n++;bl_count[8]++;}while(n<=255){static_ltree[n*2+1]/*.Len*/=9;n++;bl_count[9]++;}while(n<=279){static_ltree[n*2+1]/*.Len*/=7;n++;bl_count[7]++;}while(n<=287){static_ltree[n*2+1]/*.Len*/=8;n++;bl_count[8]++;}/* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */gen_codes(static_ltree,L_CODES+1,bl_count);/* The static distance tree is trivial: */for(n=0;n<D_CODES;n++){static_dtree[n*2+1]/*.Len*/=5;static_dtree[n*2]/*.Code*/=bi_reverse(n,5);}// Now data ready and we can init static trees\nstatic_l_desc=new StaticTreeDesc(static_ltree,extra_lbits,LITERALS+1,L_CODES,MAX_BITS);static_d_desc=new StaticTreeDesc(static_dtree,extra_dbits,0,D_CODES,MAX_BITS);static_bl_desc=new StaticTreeDesc(new Array(0),extra_blbits,0,BL_CODES,MAX_BL_BITS);//static_init_done = true;\n}/* ===========================================================================\n * Initialize a new block.\n */function init_block(s){var n;/* iterates over tree elements */ /* Initialize the trees. */for(n=0;n<L_CODES;n++){s.dyn_ltree[n*2]/*.Freq*/=0;}for(n=0;n<D_CODES;n++){s.dyn_dtree[n*2]/*.Freq*/=0;}for(n=0;n<BL_CODES;n++){s.bl_tree[n*2]/*.Freq*/=0;}s.dyn_ltree[END_BLOCK*2]/*.Freq*/=1;s.opt_len=s.static_len=0;s.last_lit=s.matches=0;}/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */function bi_windup(s){if(s.bi_valid>8){put_short(s,s.bi_buf);}else if(s.bi_valid>0){//put_byte(s, (Byte)s->bi_buf);\ns.pending_buf[s.pending++]=s.bi_buf;}s.bi_buf=0;s.bi_valid=0;}/* ===========================================================================\n * Copy a stored block, storing first the length and its\n * one's complement if requested.\n */function copy_block(s,buf,len,header)//DeflateState *s;\n//charf    *buf;    /* the input data */\n//unsigned len;     /* its length */\n//int      header;  /* true if block header must be written */\n{bi_windup(s);/* align on byte boundary */if(header){put_short(s,len);put_short(s,~len);}//  while (len--) {\n//    put_byte(s, *buf++);\n//  }\nutils.arraySet(s.pending_buf,s.window,buf,len,s.pending);s.pending+=len;}/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */function smaller(tree,n,m,depth){var _n2=n*2;var _m2=m*2;return tree[_n2]/*.Freq*/<tree[_m2]/*.Freq*/||tree[_n2]/*.Freq*/===tree[_m2]/*.Freq*/&&depth[n]<=depth[m];}/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */function pqdownheap(s,tree,k)//    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n{var v=s.heap[k];var j=k<<1;/* left son of k */while(j<=s.heap_len){/* Set j to the smallest of the two sons: */if(j<s.heap_len&&smaller(tree,s.heap[j+1],s.heap[j],s.depth)){j++;}/* Exit if v is smaller than both sons */if(smaller(tree,v,s.heap[j],s.depth)){break;}/* Exchange v with the smallest son */s.heap[k]=s.heap[j];k=j;/* And continue down the tree, setting j to the left son of k */j<<=1;}s.heap[k]=v;}// inlined manually\n// var SMALLEST = 1;\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */function compress_block(s,ltree,dtree)//    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n{var dist;/* distance of matched string */var lc;/* match length or unmatched char (if dist == 0) */var lx=0;/* running index in l_buf */var code;/* the code to send */var extra;/* number of extra bits to send */if(s.last_lit!==0){do{dist=s.pending_buf[s.d_buf+lx*2]<<8|s.pending_buf[s.d_buf+lx*2+1];lc=s.pending_buf[s.l_buf+lx];lx++;if(dist===0){send_code(s,lc,ltree);/* send a literal byte */ //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n}else{/* Here, lc is the match length - MIN_MATCH */code=_length_code[lc];send_code(s,code+LITERALS+1,ltree);/* send the length code */extra=extra_lbits[code];if(extra!==0){lc-=base_length[code];send_bits(s,lc,extra);/* send the extra length bits */}dist--;/* dist is now the match distance - 1 */code=d_code(dist);//Assert (code < D_CODES, \"bad d_code\");\nsend_code(s,code,dtree);/* send the distance code */extra=extra_dbits[code];if(extra!==0){dist-=base_dist[code];send_bits(s,dist,extra);/* send the extra distance bits */}}/* literal or match pair ? */ /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */ //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n//       \"pendingBuf overflow\");\n}while(lx<s.last_lit);}send_code(s,END_BLOCK,ltree);}/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */function build_tree(s,desc)//    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n{var tree=desc.dyn_tree;var stree=desc.stat_desc.static_tree;var has_stree=desc.stat_desc.has_stree;var elems=desc.stat_desc.elems;var n,m;/* iterate over heap elements */var max_code=-1;/* largest code with non zero frequency */var node;/* new node being created */ /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */s.heap_len=0;s.heap_max=HEAP_SIZE;for(n=0;n<elems;n++){if(tree[n*2]/*.Freq*/!==0){s.heap[++s.heap_len]=max_code=n;s.depth[n]=0;}else{tree[n*2+1]/*.Len*/=0;}}/* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */while(s.heap_len<2){node=s.heap[++s.heap_len]=max_code<2?++max_code:0;tree[node*2]/*.Freq*/=1;s.depth[node]=0;s.opt_len--;if(has_stree){s.static_len-=stree[node*2+1]/*.Len*/;}/* node is 0 or 1 so it does not have extra bits */}desc.max_code=max_code;/* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */for(n=s.heap_len>>1/*int /2*/;n>=1;n--){pqdownheap(s,tree,n);}/* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */node=elems;/* next internal node of the tree */do{//pqremove(s, tree, n);  /* n = node of least frequency */\n/*** pqremove ***/n=s.heap[1/*SMALLEST*/];s.heap[1/*SMALLEST*/]=s.heap[s.heap_len--];pqdownheap(s,tree,1/*SMALLEST*/);/***/m=s.heap[1/*SMALLEST*/];/* m = node of next least frequency */s.heap[--s.heap_max]=n;/* keep the nodes sorted by frequency */s.heap[--s.heap_max]=m;/* Create a new node father of n and m */tree[node*2]/*.Freq*/=tree[n*2]/*.Freq*/+tree[m*2]/*.Freq*/;s.depth[node]=(s.depth[n]>=s.depth[m]?s.depth[n]:s.depth[m])+1;tree[n*2+1]/*.Dad*/=tree[m*2+1]/*.Dad*/=node;/* and insert the new node in the heap */s.heap[1/*SMALLEST*/]=node++;pqdownheap(s,tree,1/*SMALLEST*/);}while(s.heap_len>=2);s.heap[--s.heap_max]=s.heap[1/*SMALLEST*/];/* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */gen_bitlen(s,desc);/* The field len is now set, we can generate the bit codes */gen_codes(tree,max_code,s.bl_count);}/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */function scan_tree(s,tree,max_code)//    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n{var n;/* iterates over all tree elements */var prevlen=-1;/* last emitted length */var curlen;/* length of current code */var nextlen=tree[0*2+1]/*.Len*/;/* length of next code */var count=0;/* repeat count of the current code */var max_count=7;/* max repeat count */var min_count=4;/* min repeat count */if(nextlen===0){max_count=138;min_count=3;}tree[(max_code+1)*2+1]/*.Len*/=0xffff;/* guard */for(n=0;n<=max_code;n++){curlen=nextlen;nextlen=tree[(n+1)*2+1]/*.Len*/;if(++count<max_count&&curlen===nextlen){continue;}else if(count<min_count){s.bl_tree[curlen*2]/*.Freq*/+=count;}else if(curlen!==0){if(curlen!==prevlen){s.bl_tree[curlen*2]/*.Freq*/++;}s.bl_tree[REP_3_6*2]/*.Freq*/++;}else if(count<=10){s.bl_tree[REPZ_3_10*2]/*.Freq*/++;}else{s.bl_tree[REPZ_11_138*2]/*.Freq*/++;}count=0;prevlen=curlen;if(nextlen===0){max_count=138;min_count=3;}else if(curlen===nextlen){max_count=6;min_count=3;}else{max_count=7;min_count=4;}}}/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */function send_tree(s,tree,max_code)//    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n{var n;/* iterates over all tree elements */var prevlen=-1;/* last emitted length */var curlen;/* length of current code */var nextlen=tree[0*2+1]/*.Len*/;/* length of next code */var count=0;/* repeat count of the current code */var max_count=7;/* max repeat count */var min_count=4;/* min repeat count */ /* tree[max_code+1].Len = -1; */ /* guard already set */if(nextlen===0){max_count=138;min_count=3;}for(n=0;n<=max_code;n++){curlen=nextlen;nextlen=tree[(n+1)*2+1]/*.Len*/;if(++count<max_count&&curlen===nextlen){continue;}else if(count<min_count){do{send_code(s,curlen,s.bl_tree);}while(--count!==0);}else if(curlen!==0){if(curlen!==prevlen){send_code(s,curlen,s.bl_tree);count--;}//Assert(count >= 3 && count <= 6, \" 3_6?\");\nsend_code(s,REP_3_6,s.bl_tree);send_bits(s,count-3,2);}else if(count<=10){send_code(s,REPZ_3_10,s.bl_tree);send_bits(s,count-3,3);}else{send_code(s,REPZ_11_138,s.bl_tree);send_bits(s,count-11,7);}count=0;prevlen=curlen;if(nextlen===0){max_count=138;min_count=3;}else if(curlen===nextlen){max_count=6;min_count=3;}else{max_count=7;min_count=4;}}}/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */function build_bl_tree(s){var max_blindex;/* index of last bit length code of non zero freq */ /* Determine the bit length frequencies for literal and distance trees */scan_tree(s,s.dyn_ltree,s.l_desc.max_code);scan_tree(s,s.dyn_dtree,s.d_desc.max_code);/* Build the bit length tree: */build_tree(s,s.bl_desc);/* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */ /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */for(max_blindex=BL_CODES-1;max_blindex>=3;max_blindex--){if(s.bl_tree[bl_order[max_blindex]*2+1]/*.Len*/!==0){break;}}/* Update opt_len to include the bit length tree and counts */s.opt_len+=3*(max_blindex+1)+5+5+4;//Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n//        s->opt_len, s->static_len));\nreturn max_blindex;}/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */function send_all_trees(s,lcodes,dcodes,blcodes)//    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n{var rank;/* index in bl_order */ //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n//Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n//        \"too many codes\");\n//Tracev((stderr, \"\\nbl counts: \"));\nsend_bits(s,lcodes-257,5);/* not +255 as stated in appnote.txt */send_bits(s,dcodes-1,5);send_bits(s,blcodes-4,4);/* not -3 as stated in appnote.txt */for(rank=0;rank<blcodes;rank++){//Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\nsend_bits(s,s.bl_tree[bl_order[rank]*2+1]/*.Len*/,3);}//Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\nsend_tree(s,s.dyn_ltree,lcodes-1);/* literal tree */ //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\nsend_tree(s,s.dyn_dtree,dcodes-1);/* distance tree */ //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n}/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"black list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */function detect_data_type(s){/* black_mask is the bit mask of black-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */var black_mask=0xf3ffc07f;var n;/* Check for non-textual (\"black-listed\") bytes. */for(n=0;n<=31;n++,black_mask>>>=1){if(black_mask&1&&s.dyn_ltree[n*2]/*.Freq*/!==0){return Z_BINARY;}}/* Check for textual (\"white-listed\") bytes. */if(s.dyn_ltree[9*2]/*.Freq*/!==0||s.dyn_ltree[10*2]/*.Freq*/!==0||s.dyn_ltree[13*2]/*.Freq*/!==0){return Z_TEXT;}for(n=32;n<LITERALS;n++){if(s.dyn_ltree[n*2]/*.Freq*/!==0){return Z_TEXT;}}/* There are no \"black-listed\" or \"white-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */return Z_BINARY;}var static_init_done=false;/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */function _tr_init(s){if(!static_init_done){tr_static_init();static_init_done=true;}s.l_desc=new TreeDesc(s.dyn_ltree,static_l_desc);s.d_desc=new TreeDesc(s.dyn_dtree,static_d_desc);s.bl_desc=new TreeDesc(s.bl_tree,static_bl_desc);s.bi_buf=0;s.bi_valid=0;/* Initialize the first block of the first file: */init_block(s);}/* ===========================================================================\n * Send a stored block\n */function _tr_stored_block(s,buf,stored_len,last)//DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{send_bits(s,(STORED_BLOCK<<1)+(last?1:0),3);/* send block type */copy_block(s,buf,stored_len,true);/* with header */}/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */function _tr_align(s){send_bits(s,STATIC_TREES<<1,3);send_code(s,END_BLOCK,static_ltree);bi_flush(s);}/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */function _tr_flush_block(s,buf,stored_len,last)//DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{var opt_lenb,static_lenb;/* opt_len and static_len in bytes */var max_blindex=0;/* index of last bit length code of non zero freq */ /* Build the Huffman trees unless a stored block is forced */if(s.level>0){/* Check if the file is binary or text */if(s.strm.data_type===Z_UNKNOWN){s.strm.data_type=detect_data_type(s);}/* Construct the literal and distance trees */build_tree(s,s.l_desc);// Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n//        s->static_len));\nbuild_tree(s,s.d_desc);// Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n//        s->static_len));\n/* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */ /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */max_blindex=build_bl_tree(s);/* Determine the best encoding. Compute the block lengths in bytes. */opt_lenb=s.opt_len+3+7>>>3;static_lenb=s.static_len+3+7>>>3;// Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n//        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n//        s->last_lit));\nif(static_lenb<=opt_lenb){opt_lenb=static_lenb;}}else{// Assert(buf != (char*)0, \"lost buf\");\nopt_lenb=static_lenb=stored_len+5;/* force a stored block */}if(stored_len+4<=opt_lenb&&buf!==-1){/* 4: two words for the lengths */ /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */_tr_stored_block(s,buf,stored_len,last);}else if(s.strategy===Z_FIXED||static_lenb===opt_lenb){send_bits(s,(STATIC_TREES<<1)+(last?1:0),3);compress_block(s,static_ltree,static_dtree);}else{send_bits(s,(DYN_TREES<<1)+(last?1:0),3);send_all_trees(s,s.l_desc.max_code+1,s.d_desc.max_code+1,max_blindex+1);compress_block(s,s.dyn_ltree,s.dyn_dtree);}// Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n/* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */init_block(s);if(last){bi_windup(s);}// Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n//       s->compressed_len-7*last));\n}/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */function _tr_tally(s,dist,lc)//    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n{//var out_length, in_length, dcode;\ns.pending_buf[s.d_buf+s.last_lit*2]=dist>>>8&0xff;s.pending_buf[s.d_buf+s.last_lit*2+1]=dist&0xff;s.pending_buf[s.l_buf+s.last_lit]=lc&0xff;s.last_lit++;if(dist===0){/* lc is the unmatched char */s.dyn_ltree[lc*2]/*.Freq*/++;}else{s.matches++;/* Here, lc is the match length - MIN_MATCH */dist--;/* dist = match distance - 1 */ //Assert((ush)dist < (ush)MAX_DIST(s) &&\n//       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n//       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\ns.dyn_ltree[(_length_code[lc]+LITERALS+1)*2]/*.Freq*/++;s.dyn_dtree[d_code(dist)*2]/*.Freq*/++;}// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef TRUNCATE_BLOCK\n//  /* Try to guess if it is profitable to stop the current block here */\n//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n//    /* Compute an upper bound for the compressed length */\n//    out_length = s.last_lit*8;\n//    in_length = s.strstart - s.block_start;\n//\n//    for (dcode = 0; dcode < D_CODES; dcode++) {\n//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n//    }\n//    out_length >>>= 3;\n//    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n//    //       s->last_lit, in_length, out_length,\n//    //       100L - out_length*100L/in_length));\n//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n//      return true;\n//    }\n//  }\n//#endif\nreturn s.last_lit===s.lit_bufsize-1;/* We avoid equality with lit_bufsize because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */}exports._tr_init=_tr_init;exports._tr_stored_block=_tr_stored_block;exports._tr_flush_block=_tr_flush_block;exports._tr_tally=_tr_tally;exports._tr_align=_tr_align;","map":{"version":3,"names":["utils","require","Z_FIXED","Z_BINARY","Z_TEXT","Z_UNKNOWN","zero","buf","len","length","STORED_BLOCK","STATIC_TREES","DYN_TREES","MIN_MATCH","MAX_MATCH","LENGTH_CODES","LITERALS","L_CODES","D_CODES","BL_CODES","HEAP_SIZE","MAX_BITS","Buf_size","MAX_BL_BITS","END_BLOCK","REP_3_6","REPZ_3_10","REPZ_11_138","extra_lbits","extra_dbits","extra_blbits","bl_order","DIST_CODE_LEN","static_ltree","Array","static_dtree","_dist_code","_length_code","base_length","base_dist","StaticTreeDesc","static_tree","extra_bits","extra_base","elems","max_length","has_stree","static_l_desc","static_d_desc","static_bl_desc","TreeDesc","dyn_tree","stat_desc","max_code","d_code","dist","put_short","s","w","pending_buf","pending","send_bits","value","bi_valid","bi_buf","send_code","c","tree","bi_reverse","code","res","bi_flush","gen_bitlen","desc","stree","extra","base","h","n","m","bits","xbits","f","overflow","bl_count","heap","heap_max","opt_len","static_len","gen_codes","next_code","tr_static_init","init_block","dyn_ltree","dyn_dtree","bl_tree","last_lit","matches","bi_windup","copy_block","header","arraySet","window","smaller","depth","_n2","_m2","pqdownheap","k","v","j","heap_len","compress_block","ltree","dtree","lc","lx","d_buf","l_buf","build_tree","node","scan_tree","prevlen","curlen","nextlen","count","max_count","min_count","send_tree","build_bl_tree","max_blindex","l_desc","d_desc","bl_desc","send_all_trees","lcodes","dcodes","blcodes","rank","detect_data_type","black_mask","static_init_done","_tr_init","_tr_stored_block","stored_len","last","_tr_align","_tr_flush_block","opt_lenb","static_lenb","level","strm","data_type","strategy","_tr_tally","lit_bufsize","exports"],"sources":["/usr/local/lib/node_modules/expo-cli/node_modules/pako/lib/zlib/trees.js"],"sourcesContent":["'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n/* eslint-disable space-unary-ops */\n\nvar utils = require('../utils/common');\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n//var Z_FILTERED          = 1;\n//var Z_HUFFMAN_ONLY      = 2;\n//var Z_RLE               = 3;\nvar Z_FIXED               = 4;\n//var Z_DEFAULT_STRATEGY  = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\nvar Z_BINARY              = 0;\nvar Z_TEXT                = 1;\n//var Z_ASCII             = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n/*============================================================================*/\n\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n// From zutil.h\n\nvar STORED_BLOCK = 0;\nvar STATIC_TREES = 1;\nvar DYN_TREES    = 2;\n/* The three kinds of block type */\n\nvar MIN_MATCH    = 3;\nvar MAX_MATCH    = 258;\n/* The minimum and maximum match lengths */\n\n// From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\n\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\n\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nvar D_CODES       = 30;\n/* number of distance codes */\n\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\n\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\n\nvar MAX_BITS      = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar Buf_size      = 16;\n/* size of bit buffer in bi_buf */\n\n\n/* ===========================================================================\n * Constants\n */\n\nvar MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\nvar END_BLOCK   = 256;\n/* end of block literal code */\n\nvar REP_3_6     = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\nvar REPZ_3_10   = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\nvar REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n/* eslint-disable comma-spacing,array-bracket-spacing */\nvar extra_lbits =   /* extra bits for each length code */\n  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];\n\nvar extra_dbits =   /* extra bits for each distance code */\n  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];\n\nvar extra_blbits =  /* extra bits for each bit length code */\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];\n\nvar bl_order =\n  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];\n/* eslint-enable comma-spacing,array-bracket-spacing */\n\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n\n// We pre-fill arrays with 0 to avoid uninitialized gaps\n\nvar DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\nvar static_ltree  = new Array((L_CODES + 2) * 2);\nzero(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nvar static_dtree  = new Array(D_CODES * 2);\nzero(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nvar _dist_code    = new Array(DIST_CODE_LEN);\nzero(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nvar _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);\nzero(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nvar base_length   = new Array(LENGTH_CODES);\nzero(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nvar base_dist     = new Array(D_CODES);\nzero(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */\n\n\nfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n\n  this.static_tree  = static_tree;  /* static tree or NULL */\n  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n  this.extra_base   = extra_base;   /* base index for extra_bits */\n  this.elems        = elems;        /* max number of elements in the tree */\n  this.max_length   = max_length;   /* max bit length for the codes */\n\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\n  this.has_stree    = static_tree && static_tree.length;\n}\n\n\nvar static_l_desc;\nvar static_d_desc;\nvar static_bl_desc;\n\n\nfunction TreeDesc(dyn_tree, stat_desc) {\n  this.dyn_tree = dyn_tree;     /* the dynamic tree */\n  this.max_code = 0;            /* largest code with non zero frequency */\n  this.stat_desc = stat_desc;   /* the corresponding static tree */\n}\n\n\n\nfunction d_code(dist) {\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n}\n\n\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\nfunction put_short(s, w) {\n//    put_byte(s, (uch)((w) & 0xff));\n//    put_byte(s, (uch)((ush)(w) >> 8));\n  s.pending_buf[s.pending++] = (w) & 0xff;\n  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n}\n\n\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\nfunction send_bits(s, value, length) {\n  if (s.bi_valid > (Buf_size - length)) {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    put_short(s, s.bi_buf);\n    s.bi_buf = value >> (Buf_size - s.bi_valid);\n    s.bi_valid += length - Buf_size;\n  } else {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    s.bi_valid += length;\n  }\n}\n\n\nfunction send_code(s, c, tree) {\n  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\n}\n\n\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nfunction bi_reverse(code, len) {\n  var res = 0;\n  do {\n    res |= code & 1;\n    code >>>= 1;\n    res <<= 1;\n  } while (--len > 0);\n  return res >>> 1;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\nfunction bi_flush(s) {\n  if (s.bi_valid === 16) {\n    put_short(s, s.bi_buf);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n\n  } else if (s.bi_valid >= 8) {\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n    s.bi_buf >>= 8;\n    s.bi_valid -= 8;\n  }\n}\n\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nfunction gen_bitlen(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n{\n  var tree            = desc.dyn_tree;\n  var max_code        = desc.max_code;\n  var stree           = desc.stat_desc.static_tree;\n  var has_stree       = desc.stat_desc.has_stree;\n  var extra           = desc.stat_desc.extra_bits;\n  var base            = desc.stat_desc.extra_base;\n  var max_length      = desc.stat_desc.max_length;\n  var h;              /* heap index */\n  var n, m;           /* iterate over the tree elements */\n  var bits;           /* bit length */\n  var xbits;          /* extra bits */\n  var f;              /* frequency */\n  var overflow = 0;   /* number of elements with bit length too large */\n\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    s.bl_count[bits] = 0;\n  }\n\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\n\n  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n    n = s.heap[h];\n    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n    if (bits > max_length) {\n      bits = max_length;\n      overflow++;\n    }\n    tree[n * 2 + 1]/*.Len*/ = bits;\n    /* We overwrite tree[n].Dad which is no longer needed */\n\n    if (n > max_code) { continue; } /* not a leaf node */\n\n    s.bl_count[bits]++;\n    xbits = 0;\n    if (n >= base) {\n      xbits = extra[n - base];\n    }\n    f = tree[n * 2]/*.Freq*/;\n    s.opt_len += f * (bits + xbits);\n    if (has_stree) {\n      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\n    }\n  }\n  if (overflow === 0) { return; }\n\n  // Trace((stderr,\"\\nbit length overflow\\n\"));\n  /* This happens for example on obj2 and pic of the Calgary corpus */\n\n  /* Find the first bit length which could increase: */\n  do {\n    bits = max_length - 1;\n    while (s.bl_count[bits] === 0) { bits--; }\n    s.bl_count[bits]--;      /* move one leaf down the tree */\n    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n    s.bl_count[max_length]--;\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n    overflow -= 2;\n  } while (overflow > 0);\n\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */\n  for (bits = max_length; bits !== 0; bits--) {\n    n = s.bl_count[bits];\n    while (n !== 0) {\n      m = s.heap[--h];\n      if (m > max_code) { continue; }\n      if (tree[m * 2 + 1]/*.Len*/ !== bits) {\n        // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\n        tree[m * 2 + 1]/*.Len*/ = bits;\n      }\n      n--;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nfunction gen_codes(tree, max_code, bl_count)\n//    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n{\n  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */\n  var code = 0;              /* running code value */\n  var bits;                  /* bit index */\n  var n;                     /* code index */\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n  for (bits = 1; bits <= MAX_BITS; bits++) {\n    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;\n  }\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //        \"inconsistent bit counts\");\n  //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n  for (n = 0;  n <= max_code; n++) {\n    var len = tree[n * 2 + 1]/*.Len*/;\n    if (len === 0) { continue; }\n    /* Now reverse the bits */\n    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n\n    //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n  }\n}\n\n\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\nfunction tr_static_init() {\n  var n;        /* iterates over tree elements */\n  var bits;     /* bit counter */\n  var length;   /* length value */\n  var code;     /* code value */\n  var dist;     /* distance index */\n  var bl_count = new Array(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  // do check in _tr_init()\n  //if (static_init_done) return;\n\n  /* For some embedded targets, global variables are not initialized: */\n/*#ifdef NO_INIT_GLOBAL_POINTERS\n  static_l_desc.static_tree = static_ltree;\n  static_l_desc.extra_bits = extra_lbits;\n  static_d_desc.static_tree = static_dtree;\n  static_d_desc.extra_bits = extra_dbits;\n  static_bl_desc.extra_bits = extra_blbits;\n#endif*/\n\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\n  length = 0;\n  for (code = 0; code < LENGTH_CODES - 1; code++) {\n    base_length[code] = length;\n    for (n = 0; n < (1 << extra_lbits[code]); n++) {\n      _length_code[length++] = code;\n    }\n  }\n  //Assert (length == 256, \"tr_static_init: length != 256\");\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n  _length_code[length - 1] = code;\n\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n  dist = 0;\n  for (code = 0; code < 16; code++) {\n    base_dist[code] = dist;\n    for (n = 0; n < (1 << extra_dbits[code]); n++) {\n      _dist_code[dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: dist != 256\");\n  dist >>= 7; /* from now on, all distances are divided by 128 */\n  for (; code < D_CODES; code++) {\n    base_dist[code] = dist << 7;\n    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n      _dist_code[256 + dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n  /* Construct the codes of the static literal tree */\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    bl_count[bits] = 0;\n  }\n\n  n = 0;\n  while (n <= 143) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  while (n <= 255) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 9;\n    n++;\n    bl_count[9]++;\n  }\n  while (n <= 279) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 7;\n    n++;\n    bl_count[7]++;\n  }\n  while (n <= 287) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n  gen_codes(static_ltree, L_CODES + 1, bl_count);\n\n  /* The static distance tree is trivial: */\n  for (n = 0; n < D_CODES; n++) {\n    static_dtree[n * 2 + 1]/*.Len*/ = 5;\n    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\n  }\n\n  // Now data ready and we can init static trees\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);\n  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);\n\n  //static_init_done = true;\n}\n\n\n/* ===========================================================================\n * Initialize a new block.\n */\nfunction init_block(s) {\n  var n; /* iterates over tree elements */\n\n  /* Initialize the trees. */\n  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\n\n  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\n  s.opt_len = s.static_len = 0;\n  s.last_lit = s.matches = 0;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\nfunction bi_windup(s)\n{\n  if (s.bi_valid > 8) {\n    put_short(s, s.bi_buf);\n  } else if (s.bi_valid > 0) {\n    //put_byte(s, (Byte)s->bi_buf);\n    s.pending_buf[s.pending++] = s.bi_buf;\n  }\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n}\n\n/* ===========================================================================\n * Copy a stored block, storing first the length and its\n * one's complement if requested.\n */\nfunction copy_block(s, buf, len, header)\n//DeflateState *s;\n//charf    *buf;    /* the input data */\n//unsigned len;     /* its length */\n//int      header;  /* true if block header must be written */\n{\n  bi_windup(s);        /* align on byte boundary */\n\n  if (header) {\n    put_short(s, len);\n    put_short(s, ~len);\n  }\n//  while (len--) {\n//    put_byte(s, *buf++);\n//  }\n  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\n  s.pending += len;\n}\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\nfunction smaller(tree, n, m, depth) {\n  var _n2 = n * 2;\n  var _m2 = m * 2;\n  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n}\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nfunction pqdownheap(s, tree, k)\n//    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n{\n  var v = s.heap[k];\n  var j = k << 1;  /* left son of k */\n  while (j <= s.heap_len) {\n    /* Set j to the smallest of the two sons: */\n    if (j < s.heap_len &&\n      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n      j++;\n    }\n    /* Exit if v is smaller than both sons */\n    if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n\n    /* Exchange v with the smallest son */\n    s.heap[k] = s.heap[j];\n    k = j;\n\n    /* And continue down the tree, setting j to the left son of k */\n    j <<= 1;\n  }\n  s.heap[k] = v;\n}\n\n\n// inlined manually\n// var SMALLEST = 1;\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nfunction compress_block(s, ltree, dtree)\n//    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n{\n  var dist;           /* distance of matched string */\n  var lc;             /* match length or unmatched char (if dist == 0) */\n  var lx = 0;         /* running index in l_buf */\n  var code;           /* the code to send */\n  var extra;          /* number of extra bits to send */\n\n  if (s.last_lit !== 0) {\n    do {\n      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);\n      lc = s.pending_buf[s.l_buf + lx];\n      lx++;\n\n      if (dist === 0) {\n        send_code(s, lc, ltree); /* send a literal byte */\n        //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n      } else {\n        /* Here, lc is the match length - MIN_MATCH */\n        code = _length_code[lc];\n        send_code(s, code + LITERALS + 1, ltree); /* send the length code */\n        extra = extra_lbits[code];\n        if (extra !== 0) {\n          lc -= base_length[code];\n          send_bits(s, lc, extra);       /* send the extra length bits */\n        }\n        dist--; /* dist is now the match distance - 1 */\n        code = d_code(dist);\n        //Assert (code < D_CODES, \"bad d_code\");\n\n        send_code(s, code, dtree);       /* send the distance code */\n        extra = extra_dbits[code];\n        if (extra !== 0) {\n          dist -= base_dist[code];\n          send_bits(s, dist, extra);   /* send the extra distance bits */\n        }\n      } /* literal or match pair ? */\n\n      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n      //       \"pendingBuf overflow\");\n\n    } while (lx < s.last_lit);\n  }\n\n  send_code(s, END_BLOCK, ltree);\n}\n\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nfunction build_tree(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n{\n  var tree     = desc.dyn_tree;\n  var stree    = desc.stat_desc.static_tree;\n  var has_stree = desc.stat_desc.has_stree;\n  var elems    = desc.stat_desc.elems;\n  var n, m;          /* iterate over heap elements */\n  var max_code = -1; /* largest code with non zero frequency */\n  var node;          /* new node being created */\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n  s.heap_len = 0;\n  s.heap_max = HEAP_SIZE;\n\n  for (n = 0; n < elems; n++) {\n    if (tree[n * 2]/*.Freq*/ !== 0) {\n      s.heap[++s.heap_len] = max_code = n;\n      s.depth[n] = 0;\n\n    } else {\n      tree[n * 2 + 1]/*.Len*/ = 0;\n    }\n  }\n\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n  while (s.heap_len < 2) {\n    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n    tree[node * 2]/*.Freq*/ = 1;\n    s.depth[node] = 0;\n    s.opt_len--;\n\n    if (has_stree) {\n      s.static_len -= stree[node * 2 + 1]/*.Len*/;\n    }\n    /* node is 0 or 1 so it does not have extra bits */\n  }\n  desc.max_code = max_code;\n\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n  node = elems;              /* next internal node of the tree */\n  do {\n    //pqremove(s, tree, n);  /* n = node of least frequency */\n    /*** pqremove ***/\n    n = s.heap[1/*SMALLEST*/];\n    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n    /***/\n\n    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n\n    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n    s.heap[--s.heap_max] = m;\n\n    /* Create a new node father of n and m */\n    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\n\n    /* and insert the new node in the heap */\n    s.heap[1/*SMALLEST*/] = node++;\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n\n  } while (s.heap_len >= 2);\n\n  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n  gen_bitlen(s, desc);\n\n  /* The field len is now set, we can generate the bit codes */\n  gen_codes(tree, max_code, s.bl_count);\n}\n\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\nfunction scan_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      s.bl_tree[curlen * 2]/*.Freq*/ += count;\n\n    } else if (curlen !== 0) {\n\n      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\n\n    } else if (count <= 10) {\n      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\n\n    } else {\n      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\n    }\n\n    count = 0;\n    prevlen = curlen;\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nfunction send_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  /* tree[max_code+1].Len = -1; */  /* guard already set */\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        send_code(s, curlen, s.bl_tree);\n        count--;\n      }\n      //Assert(count >= 3 && count <= 6, \" 3_6?\");\n      send_code(s, REP_3_6, s.bl_tree);\n      send_bits(s, count - 3, 2);\n\n    } else if (count <= 10) {\n      send_code(s, REPZ_3_10, s.bl_tree);\n      send_bits(s, count - 3, 3);\n\n    } else {\n      send_code(s, REPZ_11_138, s.bl_tree);\n      send_bits(s, count - 11, 7);\n    }\n\n    count = 0;\n    prevlen = curlen;\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nfunction build_bl_tree(s) {\n  var max_blindex;  /* index of last bit length code of non zero freq */\n\n  /* Determine the bit length frequencies for literal and distance trees */\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n  /* Build the bit length tree: */\n  build_tree(s, s.bl_desc);\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\n      break;\n    }\n  }\n  /* Update opt_len to include the bit length tree and counts */\n  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n  //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n  //        s->opt_len, s->static_len));\n\n  return max_blindex;\n}\n\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nfunction send_all_trees(s, lcodes, dcodes, blcodes)\n//    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n{\n  var rank;                    /* index in bl_order */\n\n  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //        \"too many codes\");\n  //Tracev((stderr, \"\\nbl counts: \"));\n  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n  send_bits(s, dcodes - 1,   5);\n  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\n  for (rank = 0; rank < blcodes; rank++) {\n    //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\n  }\n  //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n  //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n  //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n}\n\n\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"black list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\nfunction detect_data_type(s) {\n  /* black_mask is the bit mask of black-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */\n  var black_mask = 0xf3ffc07f;\n  var n;\n\n  /* Check for non-textual (\"black-listed\") bytes. */\n  for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\n      return Z_BINARY;\n    }\n  }\n\n  /* Check for textual (\"white-listed\") bytes. */\n  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n    return Z_TEXT;\n  }\n  for (n = 32; n < LITERALS; n++) {\n    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n      return Z_TEXT;\n    }\n  }\n\n  /* There are no \"black-listed\" or \"white-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */\n  return Z_BINARY;\n}\n\n\nvar static_init_done = false;\n\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\nfunction _tr_init(s)\n{\n\n  if (!static_init_done) {\n    tr_static_init();\n    static_init_done = true;\n  }\n\n  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n\n  /* Initialize the first block of the first file: */\n  init_block(s);\n}\n\n\n/* ===========================================================================\n * Send a stored block\n */\nfunction _tr_stored_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\n  copy_block(s, buf, stored_len, true); /* with header */\n}\n\n\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\nfunction _tr_align(s) {\n  send_bits(s, STATIC_TREES << 1, 3);\n  send_code(s, END_BLOCK, static_ltree);\n  bi_flush(s);\n}\n\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */\nfunction _tr_flush_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n  var max_blindex = 0;        /* index of last bit length code of non zero freq */\n\n  /* Build the Huffman trees unless a stored block is forced */\n  if (s.level > 0) {\n\n    /* Check if the file is binary or text */\n    if (s.strm.data_type === Z_UNKNOWN) {\n      s.strm.data_type = detect_data_type(s);\n    }\n\n    /* Construct the literal and distance trees */\n    build_tree(s, s.l_desc);\n    // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n\n    build_tree(s, s.d_desc);\n    // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n    max_blindex = build_bl_tree(s);\n\n    /* Determine the best encoding. Compute the block lengths in bytes. */\n    opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n    static_lenb = (s.static_len + 3 + 7) >>> 3;\n\n    // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n    //        s->last_lit));\n\n    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n\n  } else {\n    // Assert(buf != (char*)0, \"lost buf\");\n    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n  }\n\n  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n    /* 4: two words for the lengths */\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    _tr_stored_block(s, buf, stored_len, last);\n\n  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n\n    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n    compress_block(s, static_ltree, static_dtree);\n\n  } else {\n    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n    compress_block(s, s.dyn_ltree, s.dyn_dtree);\n  }\n  // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n  /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */\n  init_block(s);\n\n  if (last) {\n    bi_windup(s);\n  }\n  // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n  //       s->compressed_len-7*last));\n}\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nfunction _tr_tally(s, dist, lc)\n//    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n{\n  //var out_length, in_length, dcode;\n\n  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;\n  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n\n  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n  s.last_lit++;\n\n  if (dist === 0) {\n    /* lc is the unmatched char */\n    s.dyn_ltree[lc * 2]/*.Freq*/++;\n  } else {\n    s.matches++;\n    /* Here, lc is the match length - MIN_MATCH */\n    dist--;             /* dist = match distance - 1 */\n    //Assert((ush)dist < (ush)MAX_DIST(s) &&\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;\n    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n  }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n\n//#ifdef TRUNCATE_BLOCK\n//  /* Try to guess if it is profitable to stop the current block here */\n//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n//    /* Compute an upper bound for the compressed length */\n//    out_length = s.last_lit*8;\n//    in_length = s.strstart - s.block_start;\n//\n//    for (dcode = 0; dcode < D_CODES; dcode++) {\n//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n//    }\n//    out_length >>>= 3;\n//    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n//    //       s->last_lit, in_length, out_length,\n//    //       100L - out_length*100L/in_length));\n//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n//      return true;\n//    }\n//  }\n//#endif\n\n  return (s.last_lit === s.lit_bufsize - 1);\n  /* We avoid equality with lit_bufsize because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n}\n\nexports._tr_init  = _tr_init;\nexports._tr_stored_block = _tr_stored_block;\nexports._tr_flush_block  = _tr_flush_block;\nexports._tr_tally = _tr_tally;\nexports._tr_align = _tr_align;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}