{"ast":null,"code":"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n'use strict';module.exports=Readable;/*<replacement>*/var Duplex;/*</replacement>*/Readable.ReadableState=ReadableState;/*<replacement>*/var EE=require('events').EventEmitter;var EElistenerCount=function EElistenerCount(emitter,type){return emitter.listeners(type).length;};/*</replacement>*/ /*<replacement>*/var Stream=require('./internal/streams/stream');/*</replacement>*/var Buffer=require('buffer').Buffer;var OurUint8Array=global.Uint8Array||function(){};function _uint8ArrayToBuffer(chunk){return Buffer.from(chunk);}function _isUint8Array(obj){return Buffer.isBuffer(obj)||obj instanceof OurUint8Array;}/*<replacement>*/var debugUtil=require('util');var debug;if(debugUtil&&debugUtil.debuglog){debug=debugUtil.debuglog('stream');}else{debug=function debug(){};}/*</replacement>*/var BufferList=require('./internal/streams/buffer_list');var destroyImpl=require('./internal/streams/destroy');var _require=require('./internal/streams/state'),getHighWaterMark=_require.getHighWaterMark;var _require$codes=require('../errors').codes,ERR_INVALID_ARG_TYPE=_require$codes.ERR_INVALID_ARG_TYPE,ERR_STREAM_PUSH_AFTER_EOF=_require$codes.ERR_STREAM_PUSH_AFTER_EOF,ERR_METHOD_NOT_IMPLEMENTED=_require$codes.ERR_METHOD_NOT_IMPLEMENTED,ERR_STREAM_UNSHIFT_AFTER_END_EVENT=_require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;// Lazy loaded to improve the startup performance.\nvar StringDecoder;var createReadableStreamAsyncIterator;var from;require('inherits')(Readable,Stream);var errorOrDestroy=destroyImpl.errorOrDestroy;var kProxyEvents=['error','close','destroy','pause','resume'];function prependListener(emitter,event,fn){// Sadly this is not cacheable as some libraries bundle their own\n// event emitter implementation with them.\nif(typeof emitter.prependListener==='function')return emitter.prependListener(event,fn);// This is a hack to make sure that our error handler is attached before any\n// userland ones.  NEVER DO THIS. This is here only because this code needs\n// to continue to work with older versions of Node.js that do not include\n// the prependListener() method. The goal is to eventually remove this hack.\nif(!emitter._events||!emitter._events[event])emitter.on(event,fn);else if(Array.isArray(emitter._events[event]))emitter._events[event].unshift(fn);else emitter._events[event]=[fn,emitter._events[event]];}function ReadableState(options,stream,isDuplex){Duplex=Duplex||require('./_stream_duplex');options=options||{};// Duplex streams are both readable and writable, but share\n// the same options object.\n// However, some cases require setting options to different\n// values for the readable and the writable sides of the duplex stream.\n// These options can be provided separately as readableXXX and writableXXX.\nif(typeof isDuplex!=='boolean')isDuplex=stream instanceof Duplex;// object stream flag. Used to make read(n) ignore n and to\n// make all the buffer merging and length checks go away\nthis.objectMode=!!options.objectMode;if(isDuplex)this.objectMode=this.objectMode||!!options.readableObjectMode;// the point at which it stops calling _read() to fill the buffer\n// Note: 0 is a valid value, means \"don't call _read preemptively ever\"\nthis.highWaterMark=getHighWaterMark(this,options,'readableHighWaterMark',isDuplex);// A linked list is used to store data chunks instead of an array because the\n// linked list can remove elements from the beginning faster than\n// array.shift()\nthis.buffer=new BufferList();this.length=0;this.pipes=null;this.pipesCount=0;this.flowing=null;this.ended=false;this.endEmitted=false;this.reading=false;// a flag to be able to tell if the event 'readable'/'data' is emitted\n// immediately, or on a later tick.  We set this to true at first, because\n// any actions that shouldn't happen until \"later\" should generally also\n// not happen before the first read call.\nthis.sync=true;// whenever we return null, then we set a flag to say\n// that we're awaiting a 'readable' event emission.\nthis.needReadable=false;this.emittedReadable=false;this.readableListening=false;this.resumeScheduled=false;this.paused=true;// Should close be emitted on destroy. Defaults to true.\nthis.emitClose=options.emitClose!==false;// Should .destroy() be called after 'end' (and potentially 'finish')\nthis.autoDestroy=!!options.autoDestroy;// has it been destroyed\nthis.destroyed=false;// Crypto is kind of old and crusty.  Historically, its default string\n// encoding is 'binary' so we have to make this configurable.\n// Everything else in the universe uses 'utf8', though.\nthis.defaultEncoding=options.defaultEncoding||'utf8';// the number of writers that are awaiting a drain event in .pipe()s\nthis.awaitDrain=0;// if true, a maybeReadMore has been scheduled\nthis.readingMore=false;this.decoder=null;this.encoding=null;if(options.encoding){if(!StringDecoder)StringDecoder=require('string_decoder/').StringDecoder;this.decoder=new StringDecoder(options.encoding);this.encoding=options.encoding;}}function Readable(options){Duplex=Duplex||require('./_stream_duplex');if(!(this instanceof Readable))return new Readable(options);// Checking for a Stream.Duplex instance is faster here instead of inside\n// the ReadableState constructor, at least with V8 6.5\nvar isDuplex=this instanceof Duplex;this._readableState=new ReadableState(options,this,isDuplex);// legacy\nthis.readable=true;if(options){if(typeof options.read==='function')this._read=options.read;if(typeof options.destroy==='function')this._destroy=options.destroy;}Stream.call(this);}Object.defineProperty(Readable.prototype,'destroyed',{// making it explicit this property is not enumerable\n// because otherwise some prototype manipulation in\n// userland will fail\nenumerable:false,get:function get(){if(this._readableState===undefined){return false;}return this._readableState.destroyed;},set:function set(value){// we ignore the value if the stream\n// has not been initialized yet\nif(!this._readableState){return;}// backward compatibility, the user is explicitly\n// managing destroyed\nthis._readableState.destroyed=value;}});Readable.prototype.destroy=destroyImpl.destroy;Readable.prototype._undestroy=destroyImpl.undestroy;Readable.prototype._destroy=function(err,cb){cb(err);};// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push=function(chunk,encoding){var state=this._readableState;var skipChunkCheck;if(!state.objectMode){if(typeof chunk==='string'){encoding=encoding||state.defaultEncoding;if(encoding!==state.encoding){chunk=Buffer.from(chunk,encoding);encoding='';}skipChunkCheck=true;}}else{skipChunkCheck=true;}return readableAddChunk(this,chunk,encoding,false,skipChunkCheck);};// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift=function(chunk){return readableAddChunk(this,chunk,null,true,false);};function readableAddChunk(stream,chunk,encoding,addToFront,skipChunkCheck){debug('readableAddChunk',chunk);var state=stream._readableState;if(chunk===null){state.reading=false;onEofChunk(stream,state);}else{var er;if(!skipChunkCheck)er=chunkInvalid(state,chunk);if(er){errorOrDestroy(stream,er);}else if(state.objectMode||chunk&&chunk.length>0){if(typeof chunk!=='string'&&!state.objectMode&&Object.getPrototypeOf(chunk)!==Buffer.prototype){chunk=_uint8ArrayToBuffer(chunk);}if(addToFront){if(state.endEmitted)errorOrDestroy(stream,new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream,state,chunk,true);}else if(state.ended){errorOrDestroy(stream,new ERR_STREAM_PUSH_AFTER_EOF());}else if(state.destroyed){return false;}else{state.reading=false;if(state.decoder&&!encoding){chunk=state.decoder.write(chunk);if(state.objectMode||chunk.length!==0)addChunk(stream,state,chunk,false);else maybeReadMore(stream,state);}else{addChunk(stream,state,chunk,false);}}}else if(!addToFront){state.reading=false;maybeReadMore(stream,state);}}// We can push more data if we are below the highWaterMark.\n// Also, if we have no data yet, we can stand some more bytes.\n// This is to work around cases where hwm=0, such as the repl.\nreturn!state.ended&&(state.length<state.highWaterMark||state.length===0);}function addChunk(stream,state,chunk,addToFront){if(state.flowing&&state.length===0&&!state.sync){state.awaitDrain=0;stream.emit('data',chunk);}else{// update the buffer info.\nstate.length+=state.objectMode?1:chunk.length;if(addToFront)state.buffer.unshift(chunk);else state.buffer.push(chunk);if(state.needReadable)emitReadable(stream);}maybeReadMore(stream,state);}function chunkInvalid(state,chunk){var er;if(!_isUint8Array(chunk)&&typeof chunk!=='string'&&chunk!==undefined&&!state.objectMode){er=new ERR_INVALID_ARG_TYPE('chunk',['string','Buffer','Uint8Array'],chunk);}return er;}Readable.prototype.isPaused=function(){return this._readableState.flowing===false;};// backwards compatibility.\nReadable.prototype.setEncoding=function(enc){if(!StringDecoder)StringDecoder=require('string_decoder/').StringDecoder;var decoder=new StringDecoder(enc);this._readableState.decoder=decoder;// If setEncoding(null), decoder.encoding equals utf8\nthis._readableState.encoding=this._readableState.decoder.encoding;// Iterate over current buffer to convert already stored Buffers:\nvar p=this._readableState.buffer.head;var content='';while(p!==null){content+=decoder.write(p.data);p=p.next;}this._readableState.buffer.clear();if(content!=='')this._readableState.buffer.push(content);this._readableState.length=content.length;return this;};// Don't raise the hwm > 1GB\nvar MAX_HWM=0x40000000;function computeNewHighWaterMark(n){if(n>=MAX_HWM){// TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.\nn=MAX_HWM;}else{// Get the next highest power of 2 to prevent increasing hwm excessively in\n// tiny amounts\nn--;n|=n>>>1;n|=n>>>2;n|=n>>>4;n|=n>>>8;n|=n>>>16;n++;}return n;}// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n,state){if(n<=0||state.length===0&&state.ended)return 0;if(state.objectMode)return 1;if(n!==n){// Only flow one buffer at a time\nif(state.flowing&&state.length)return state.buffer.head.data.length;else return state.length;}// If we're asking for more than the current hwm, then raise the hwm.\nif(n>state.highWaterMark)state.highWaterMark=computeNewHighWaterMark(n);if(n<=state.length)return n;// Don't have enough\nif(!state.ended){state.needReadable=true;return 0;}return state.length;}// you can override either this method, or the async _read(n) below.\nReadable.prototype.read=function(n){debug('read',n);n=parseInt(n,10);var state=this._readableState;var nOrig=n;if(n!==0)state.emittedReadable=false;// if we're doing read(0) to trigger a readable event, but we\n// already have a bunch of data in the buffer, then just trigger\n// the 'readable' event and move on.\nif(n===0&&state.needReadable&&((state.highWaterMark!==0?state.length>=state.highWaterMark:state.length>0)||state.ended)){debug('read: emitReadable',state.length,state.ended);if(state.length===0&&state.ended)endReadable(this);else emitReadable(this);return null;}n=howMuchToRead(n,state);// if we've ended, and we're now clear, then finish it up.\nif(n===0&&state.ended){if(state.length===0)endReadable(this);return null;}// All the actual chunk generation logic needs to be\n// *below* the call to _read.  The reason is that in certain\n// synthetic stream cases, such as passthrough streams, _read\n// may be a completely synchronous operation which may change\n// the state of the read buffer, providing enough data when\n// before there was *not* enough.\n//\n// So, the steps are:\n// 1. Figure out what the state of things will be after we do\n// a read from the buffer.\n//\n// 2. If that resulting state will trigger a _read, then call _read.\n// Note that this may be asynchronous, or synchronous.  Yes, it is\n// deeply ugly to write APIs this way, but that still doesn't mean\n// that the Readable class should behave improperly, as streams are\n// designed to be sync/async agnostic.\n// Take note if the _read call is sync or async (ie, if the read call\n// has returned yet), so that we know whether or not it's safe to emit\n// 'readable' etc.\n//\n// 3. Actually pull the requested chunks out of the buffer and return.\n// if we need a readable event, then we need to do some reading.\nvar doRead=state.needReadable;debug('need readable',doRead);// if we currently have less than the highWaterMark, then also read some\nif(state.length===0||state.length-n<state.highWaterMark){doRead=true;debug('length less than watermark',doRead);}// however, if we've ended, then there's no point, and if we're already\n// reading, then it's unnecessary.\nif(state.ended||state.reading){doRead=false;debug('reading or ended',doRead);}else if(doRead){debug('do read');state.reading=true;state.sync=true;// if the length is currently zero, then we *need* a readable event.\nif(state.length===0)state.needReadable=true;// call internal read method\nthis._read(state.highWaterMark);state.sync=false;// If _read pushed data synchronously, then `reading` will be false,\n// and we need to re-evaluate how much data we can return to the user.\nif(!state.reading)n=howMuchToRead(nOrig,state);}var ret;if(n>0)ret=fromList(n,state);else ret=null;if(ret===null){state.needReadable=state.length<=state.highWaterMark;n=0;}else{state.length-=n;state.awaitDrain=0;}if(state.length===0){// If we have nothing in the buffer, then we want to know\n// as soon as we *do* get something into the buffer.\nif(!state.ended)state.needReadable=true;// If we tried to read() past the EOF, then emit end on the next tick.\nif(nOrig!==n&&state.ended)endReadable(this);}if(ret!==null)this.emit('data',ret);return ret;};function onEofChunk(stream,state){debug('onEofChunk');if(state.ended)return;if(state.decoder){var chunk=state.decoder.end();if(chunk&&chunk.length){state.buffer.push(chunk);state.length+=state.objectMode?1:chunk.length;}}state.ended=true;if(state.sync){// if we are sync, wait until next tick to emit the data.\n// Otherwise we risk emitting data in the flow()\n// the readable code triggers during a read() call\nemitReadable(stream);}else{// emit 'readable' now to make sure it gets picked up.\nstate.needReadable=false;if(!state.emittedReadable){state.emittedReadable=true;emitReadable_(stream);}}}// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream){var state=stream._readableState;debug('emitReadable',state.needReadable,state.emittedReadable);state.needReadable=false;if(!state.emittedReadable){debug('emitReadable',state.flowing);state.emittedReadable=true;process.nextTick(emitReadable_,stream);}}function emitReadable_(stream){var state=stream._readableState;debug('emitReadable_',state.destroyed,state.length,state.ended);if(!state.destroyed&&(state.length||state.ended)){stream.emit('readable');state.emittedReadable=false;}// The stream needs another readable event if\n// 1. It is not flowing, as the flow mechanism will take\n//    care of it.\n// 2. It is not ended.\n// 3. It is below the highWaterMark, so we can schedule\n//    another readable later.\nstate.needReadable=!state.flowing&&!state.ended&&state.length<=state.highWaterMark;flow(stream);}// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream,state){if(!state.readingMore){state.readingMore=true;process.nextTick(maybeReadMore_,stream,state);}}function maybeReadMore_(stream,state){// Attempt to read more data if we should.\n//\n// The conditions for reading more data are (one of):\n// - Not enough data buffered (state.length < state.highWaterMark). The loop\n//   is responsible for filling the buffer with enough data if such data\n//   is available. If highWaterMark is 0 and we are not in the flowing mode\n//   we should _not_ attempt to buffer any extra data. We'll get more data\n//   when the stream consumer calls read() instead.\n// - No data in the buffer, and the stream is in flowing mode. In this mode\n//   the loop below is responsible for ensuring read() is called. Failing to\n//   call read here would abort the flow and there's no other mechanism for\n//   continuing the flow if the stream consumer has just subscribed to the\n//   'data' event.\n//\n// In addition to the above conditions to keep reading data, the following\n// conditions prevent the data from being read:\n// - The stream has ended (state.ended).\n// - There is already a pending 'read' operation (state.reading). This is a\n//   case where the the stream has called the implementation defined _read()\n//   method, but they are processing the call asynchronously and have _not_\n//   called push() with new data. In this case we skip performing more\n//   read()s. The execution ends in this method again after the _read() ends\n//   up calling push() with more data.\nwhile(!state.reading&&!state.ended&&(state.length<state.highWaterMark||state.flowing&&state.length===0)){var len=state.length;debug('maybeReadMore read 0');stream.read(0);if(len===state.length)// didn't get any data, stop spinning.\nbreak;}state.readingMore=false;}// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read=function(n){errorOrDestroy(this,new ERR_METHOD_NOT_IMPLEMENTED('_read()'));};Readable.prototype.pipe=function(dest,pipeOpts){var src=this;var state=this._readableState;switch(state.pipesCount){case 0:state.pipes=dest;break;case 1:state.pipes=[state.pipes,dest];break;default:state.pipes.push(dest);break;}state.pipesCount+=1;debug('pipe count=%d opts=%j',state.pipesCount,pipeOpts);var doEnd=(!pipeOpts||pipeOpts.end!==false)&&dest!==process.stdout&&dest!==process.stderr;var endFn=doEnd?onend:unpipe;if(state.endEmitted)process.nextTick(endFn);else src.once('end',endFn);dest.on('unpipe',onunpipe);function onunpipe(readable,unpipeInfo){debug('onunpipe');if(readable===src){if(unpipeInfo&&unpipeInfo.hasUnpiped===false){unpipeInfo.hasUnpiped=true;cleanup();}}}function onend(){debug('onend');dest.end();}// when the dest drains, it reduces the awaitDrain counter\n// on the source.  This would be more elegant with a .once()\n// handler in flow(), but adding and removing repeatedly is\n// too slow.\nvar ondrain=pipeOnDrain(src);dest.on('drain',ondrain);var cleanedUp=false;function cleanup(){debug('cleanup');// cleanup event handlers once the pipe is broken\ndest.removeListener('close',onclose);dest.removeListener('finish',onfinish);dest.removeListener('drain',ondrain);dest.removeListener('error',onerror);dest.removeListener('unpipe',onunpipe);src.removeListener('end',onend);src.removeListener('end',unpipe);src.removeListener('data',ondata);cleanedUp=true;// if the reader is waiting for a drain event from this\n// specific writer, then it would cause it to never start\n// flowing again.\n// So, if this is awaiting a drain, then we just call it now.\n// If we don't know, then assume that we are waiting for one.\nif(state.awaitDrain&&(!dest._writableState||dest._writableState.needDrain))ondrain();}src.on('data',ondata);function ondata(chunk){debug('ondata');var ret=dest.write(chunk);debug('dest.write',ret);if(ret===false){// If the user unpiped during `dest.write()`, it is possible\n// to get stuck in a permanently paused state if that write\n// also returned false.\n// => Check whether `dest` is still a piping destination.\nif((state.pipesCount===1&&state.pipes===dest||state.pipesCount>1&&indexOf(state.pipes,dest)!==-1)&&!cleanedUp){debug('false write response, pause',state.awaitDrain);state.awaitDrain++;}src.pause();}}// if the dest has an error, then stop piping into it.\n// however, don't suppress the throwing behavior for this.\nfunction onerror(er){debug('onerror',er);unpipe();dest.removeListener('error',onerror);if(EElistenerCount(dest,'error')===0)errorOrDestroy(dest,er);}// Make sure our error handler is attached before userland ones.\nprependListener(dest,'error',onerror);// Both close and finish should trigger unpipe, but only once.\nfunction onclose(){dest.removeListener('finish',onfinish);unpipe();}dest.once('close',onclose);function onfinish(){debug('onfinish');dest.removeListener('close',onclose);unpipe();}dest.once('finish',onfinish);function unpipe(){debug('unpipe');src.unpipe(dest);}// tell the dest that it's being piped to\ndest.emit('pipe',src);// start the flow if it hasn't been started already.\nif(!state.flowing){debug('pipe resume');src.resume();}return dest;};function pipeOnDrain(src){return function pipeOnDrainFunctionResult(){var state=src._readableState;debug('pipeOnDrain',state.awaitDrain);if(state.awaitDrain)state.awaitDrain--;if(state.awaitDrain===0&&EElistenerCount(src,'data')){state.flowing=true;flow(src);}};}Readable.prototype.unpipe=function(dest){var state=this._readableState;var unpipeInfo={hasUnpiped:false};// if we're not piping anywhere, then do nothing.\nif(state.pipesCount===0)return this;// just one destination.  most common case.\nif(state.pipesCount===1){// passed in one, but it's not the right one.\nif(dest&&dest!==state.pipes)return this;if(!dest)dest=state.pipes;// got a match.\nstate.pipes=null;state.pipesCount=0;state.flowing=false;if(dest)dest.emit('unpipe',this,unpipeInfo);return this;}// slow case. multiple pipe destinations.\nif(!dest){// remove all.\nvar dests=state.pipes;var len=state.pipesCount;state.pipes=null;state.pipesCount=0;state.flowing=false;for(var i=0;i<len;i++){dests[i].emit('unpipe',this,{hasUnpiped:false});}return this;}// try to find the right one.\nvar index=indexOf(state.pipes,dest);if(index===-1)return this;state.pipes.splice(index,1);state.pipesCount-=1;if(state.pipesCount===1)state.pipes=state.pipes[0];dest.emit('unpipe',this,unpipeInfo);return this;};// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on=function(ev,fn){var res=Stream.prototype.on.call(this,ev,fn);var state=this._readableState;if(ev==='data'){// update readableListening so that resume() may be a no-op\n// a few lines down. This is needed to support once('readable').\nstate.readableListening=this.listenerCount('readable')>0;// Try start flowing on next tick if stream isn't explicitly paused\nif(state.flowing!==false)this.resume();}else if(ev==='readable'){if(!state.endEmitted&&!state.readableListening){state.readableListening=state.needReadable=true;state.flowing=false;state.emittedReadable=false;debug('on readable',state.length,state.reading);if(state.length){emitReadable(this);}else if(!state.reading){process.nextTick(nReadingNextTick,this);}}}return res;};Readable.prototype.addListener=Readable.prototype.on;Readable.prototype.removeListener=function(ev,fn){var res=Stream.prototype.removeListener.call(this,ev,fn);if(ev==='readable'){// We need to check if there is someone still listening to\n// readable and reset the state. However this needs to happen\n// after readable has been emitted but before I/O (nextTick) to\n// support once('readable', fn) cycles. This means that calling\n// resume within the same tick will have no\n// effect.\nprocess.nextTick(updateReadableListening,this);}return res;};Readable.prototype.removeAllListeners=function(ev){var res=Stream.prototype.removeAllListeners.apply(this,arguments);if(ev==='readable'||ev===undefined){// We need to check if there is someone still listening to\n// readable and reset the state. However this needs to happen\n// after readable has been emitted but before I/O (nextTick) to\n// support once('readable', fn) cycles. This means that calling\n// resume within the same tick will have no\n// effect.\nprocess.nextTick(updateReadableListening,this);}return res;};function updateReadableListening(self){var state=self._readableState;state.readableListening=self.listenerCount('readable')>0;if(state.resumeScheduled&&!state.paused){// flowing needs to be set to true now, otherwise\n// the upcoming resume will not flow.\nstate.flowing=true;// crude way to check if we should resume\n}else if(self.listenerCount('data')>0){self.resume();}}function nReadingNextTick(self){debug('readable nexttick read 0');self.read(0);}// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume=function(){var state=this._readableState;if(!state.flowing){debug('resume');// we flow only if there is no one listening\n// for readable, but we still have to call\n// resume()\nstate.flowing=!state.readableListening;resume(this,state);}state.paused=false;return this;};function resume(stream,state){if(!state.resumeScheduled){state.resumeScheduled=true;process.nextTick(resume_,stream,state);}}function resume_(stream,state){debug('resume',state.reading);if(!state.reading){stream.read(0);}state.resumeScheduled=false;stream.emit('resume');flow(stream);if(state.flowing&&!state.reading)stream.read(0);}Readable.prototype.pause=function(){debug('call pause flowing=%j',this._readableState.flowing);if(this._readableState.flowing!==false){debug('pause');this._readableState.flowing=false;this.emit('pause');}this._readableState.paused=true;return this;};function flow(stream){var state=stream._readableState;debug('flow',state.flowing);while(state.flowing&&stream.read()!==null){;}}// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap=function(stream){var _this=this;var state=this._readableState;var paused=false;stream.on('end',function(){debug('wrapped end');if(state.decoder&&!state.ended){var chunk=state.decoder.end();if(chunk&&chunk.length)_this.push(chunk);}_this.push(null);});stream.on('data',function(chunk){debug('wrapped data');if(state.decoder)chunk=state.decoder.write(chunk);// don't skip over falsy values in objectMode\nif(state.objectMode&&(chunk===null||chunk===undefined))return;else if(!state.objectMode&&(!chunk||!chunk.length))return;var ret=_this.push(chunk);if(!ret){paused=true;stream.pause();}});// proxy all the other methods.\n// important when wrapping filters and duplexes.\nfor(var i in stream){if(this[i]===undefined&&typeof stream[i]==='function'){this[i]=function methodWrap(method){return function methodWrapReturnFunction(){return stream[method].apply(stream,arguments);};}(i);}}// proxy certain important events.\nfor(var n=0;n<kProxyEvents.length;n++){stream.on(kProxyEvents[n],this.emit.bind(this,kProxyEvents[n]));}// when we try to consume some more bytes, simply unpause the\n// underlying stream.\nthis._read=function(n){debug('wrapped _read',n);if(paused){paused=false;stream.resume();}};return this;};if(typeof Symbol==='function'){Readable.prototype[Symbol.asyncIterator]=function(){if(createReadableStreamAsyncIterator===undefined){createReadableStreamAsyncIterator=require('./internal/streams/async_iterator');}return createReadableStreamAsyncIterator(this);};}Object.defineProperty(Readable.prototype,'readableHighWaterMark',{// making it explicit this property is not enumerable\n// because otherwise some prototype manipulation in\n// userland will fail\nenumerable:false,get:function get(){return this._readableState.highWaterMark;}});Object.defineProperty(Readable.prototype,'readableBuffer',{// making it explicit this property is not enumerable\n// because otherwise some prototype manipulation in\n// userland will fail\nenumerable:false,get:function get(){return this._readableState&&this._readableState.buffer;}});Object.defineProperty(Readable.prototype,'readableFlowing',{// making it explicit this property is not enumerable\n// because otherwise some prototype manipulation in\n// userland will fail\nenumerable:false,get:function get(){return this._readableState.flowing;},set:function set(state){if(this._readableState){this._readableState.flowing=state;}}});// exposed for testing purposes only.\nReadable._fromList=fromList;Object.defineProperty(Readable.prototype,'readableLength',{// making it explicit this property is not enumerable\n// because otherwise some prototype manipulation in\n// userland will fail\nenumerable:false,get:function get(){return this._readableState.length;}});// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n,state){// nothing buffered\nif(state.length===0)return null;var ret;if(state.objectMode)ret=state.buffer.shift();else if(!n||n>=state.length){// read it all, truncate the list\nif(state.decoder)ret=state.buffer.join('');else if(state.buffer.length===1)ret=state.buffer.first();else ret=state.buffer.concat(state.length);state.buffer.clear();}else{// read part of list\nret=state.buffer.consume(n,state.decoder);}return ret;}function endReadable(stream){var state=stream._readableState;debug('endReadable',state.endEmitted);if(!state.endEmitted){state.ended=true;process.nextTick(endReadableNT,state,stream);}}function endReadableNT(state,stream){debug('endReadableNT',state.endEmitted,state.length);// Check that we didn't get one last unshift.\nif(!state.endEmitted&&state.length===0){state.endEmitted=true;stream.readable=false;stream.emit('end');if(state.autoDestroy){// In case of duplex streams we need a way to detect\n// if the writable side is ready for autoDestroy as well\nvar wState=stream._writableState;if(!wState||wState.autoDestroy&&wState.finished){stream.destroy();}}}}if(typeof Symbol==='function'){Readable.from=function(iterable,opts){if(from===undefined){from=require('./internal/streams/from');}return from(Readable,iterable,opts);};}function indexOf(xs,x){for(var i=0,l=xs.length;i<l;i++){if(xs[i]===x)return i;}return-1;}","map":{"version":3,"names":["module","exports","Readable","Duplex","ReadableState","EE","require","EventEmitter","EElistenerCount","emitter","type","listeners","length","Stream","Buffer","OurUint8Array","global","Uint8Array","_uint8ArrayToBuffer","chunk","from","_isUint8Array","obj","isBuffer","debugUtil","debug","debuglog","BufferList","destroyImpl","_require","getHighWaterMark","_require$codes","codes","ERR_INVALID_ARG_TYPE","ERR_STREAM_PUSH_AFTER_EOF","ERR_METHOD_NOT_IMPLEMENTED","ERR_STREAM_UNSHIFT_AFTER_END_EVENT","StringDecoder","createReadableStreamAsyncIterator","errorOrDestroy","kProxyEvents","prependListener","event","fn","_events","on","Array","isArray","unshift","options","stream","isDuplex","objectMode","readableObjectMode","highWaterMark","buffer","pipes","pipesCount","flowing","ended","endEmitted","reading","sync","needReadable","emittedReadable","readableListening","resumeScheduled","paused","emitClose","autoDestroy","destroyed","defaultEncoding","awaitDrain","readingMore","decoder","encoding","_readableState","readable","read","_read","destroy","_destroy","call","Object","defineProperty","prototype","enumerable","get","undefined","set","value","_undestroy","undestroy","err","cb","push","state","skipChunkCheck","readableAddChunk","addToFront","onEofChunk","er","chunkInvalid","getPrototypeOf","addChunk","write","maybeReadMore","emit","emitReadable","isPaused","setEncoding","enc","p","head","content","data","next","clear","MAX_HWM","computeNewHighWaterMark","n","howMuchToRead","parseInt","nOrig","endReadable","doRead","ret","fromList","end","emitReadable_","process","nextTick","flow","maybeReadMore_","len","pipe","dest","pipeOpts","src","doEnd","stdout","stderr","endFn","onend","unpipe","once","onunpipe","unpipeInfo","hasUnpiped","cleanup","ondrain","pipeOnDrain","cleanedUp","removeListener","onclose","onfinish","onerror","ondata","_writableState","needDrain","indexOf","pause","resume","pipeOnDrainFunctionResult","dests","i","index","splice","ev","res","listenerCount","nReadingNextTick","addListener","updateReadableListening","removeAllListeners","apply","arguments","self","resume_","wrap","_this","methodWrap","method","methodWrapReturnFunction","bind","Symbol","asyncIterator","_fromList","shift","join","first","concat","consume","endReadableNT","wState","finished","iterable","opts","xs","x","l"],"sources":["/usr/local/lib/node_modules/expo-cli/node_modules/browserify-sign/node_modules/readable-stream/lib/_stream_readable.js"],"sourcesContent":["// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n'use strict';\n\nmodule.exports = Readable;\n/*<replacement>*/\n\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n/*<replacement>*/\n\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function EElistenerCount(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\n\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n\nvar Buffer = require('buffer').Buffer;\n\nvar OurUint8Array = global.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n/*<replacement>*/\n\n\nvar debugUtil = require('util');\n\nvar debug;\n\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function debug() {};\n}\n/*</replacement>*/\n\n\nvar BufferList = require('./internal/streams/buffer_list');\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nvar _require = require('./internal/streams/state'),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = require('../errors').codes,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.\n\n\nvar StringDecoder;\nvar createReadableStreamAsyncIterator;\nvar from;\n\nrequire('inherits')(Readable, Stream);\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n\n  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n\n  this.sync = true; // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this.paused = true; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')\n\n  this.autoDestroy = !!options.autoDestroy; // has it been destroyed\n\n  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s\n\n  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled\n\n  this.readingMore = false;\n  this.decoder = null;\n  this.encoding = null;\n\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  this._readableState = new ReadableState(options, this, isDuplex); // legacy\n\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined) {\n      return false;\n    }\n\n    return this._readableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._readableState.destroyed = value;\n  }\n});\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\n\nReadable.prototype._destroy = function (err, cb) {\n  cb(err);\n}; // Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\n\n\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n}; // Unshift should *always* be something directly out of read()\n\n\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  debug('readableAddChunk', chunk);\n  var state = stream._readableState;\n\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n\n    if (er) {\n      errorOrDestroy(stream, er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n      } else if (state.destroyed) {\n        return false;\n      } else {\n        state.reading = false;\n\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n      maybeReadMore(stream, state);\n    }\n  } // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n\n\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    state.awaitDrain = 0;\n    stream.emit('data', chunk);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n    if (state.needReadable) emitReadable(stream);\n  }\n\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n  }\n\n  return er;\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n}; // backwards compatibility.\n\n\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  var decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8\n\n  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:\n\n  var p = this._readableState.buffer.head;\n  var content = '';\n\n  while (p !== null) {\n    content += decoder.write(p.data);\n    p = p.next;\n  }\n\n  this._readableState.buffer.clear();\n\n  if (content !== '') this._readableState.buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n}; // Don't raise the hwm > 1GB\n\n\nvar MAX_HWM = 0x40000000;\n\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n\n  return n;\n} // This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\n\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  } // If we're asking for more than the current hwm, then raise the hwm.\n\n\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n; // Don't have enough\n\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n\n  return state.length;\n} // you can override either this method, or the async _read(n) below.\n\n\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n\n  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.\n\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  } // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n  // if we need a readable event, then we need to do some reading.\n\n\n  var doRead = state.needReadable;\n  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some\n\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  } // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n\n\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true; // if the length is currently zero, then we *need* a readable event.\n\n    if (state.length === 0) state.needReadable = true; // call internal read method\n\n    this._read(state.highWaterMark);\n\n    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    state.awaitDrain = 0;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.\n\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk');\n  if (state.ended) return;\n\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n\n  state.ended = true;\n\n  if (state.sync) {\n    // if we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call\n    emitReadable(stream);\n  } else {\n    // emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n\n    if (!state.emittedReadable) {\n      state.emittedReadable = true;\n      emitReadable_(stream);\n    }\n  }\n} // Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\n\n\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  debug('emitReadable', state.needReadable, state.emittedReadable);\n  state.needReadable = false;\n\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_, stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  var state = stream._readableState;\n  debug('emitReadable_', state.destroyed, state.length, state.ended);\n\n  if (!state.destroyed && (state.length || state.ended)) {\n    stream.emit('readable');\n    state.emittedReadable = false;\n  } // The stream needs another readable event if\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n\n\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n  flow(stream);\n} // at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\n\n\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n    var len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length) // didn't get any data, stop spinning.\n      break;\n  }\n\n  state.readingMore = false;\n} // abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\n\n\nReadable.prototype._read = function (n) {\n  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\n  dest.on('unpipe', onunpipe);\n\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  } // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n\n\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n  var cleanedUp = false;\n\n  function cleanup() {\n    debug('cleanup'); // cleanup event handlers once the pipe is broken\n\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n    cleanedUp = true; // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  src.on('data', ondata);\n\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    debug('dest.write', ret);\n\n    if (ret === false) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', state.awaitDrain);\n        state.awaitDrain++;\n      }\n\n      src.pause();\n    }\n  } // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n\n\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);\n  } // Make sure our error handler is attached before userland ones.\n\n\n  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.\n\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n\n  dest.once('close', onclose);\n\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  } // tell the dest that it's being piped to\n\n\n  dest.emit('pipe', src); // start the flow if it hasn't been started already.\n\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function pipeOnDrainFunctionResult() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = {\n    hasUnpiped: false\n  }; // if we're not piping anywhere, then do nothing.\n\n  if (state.pipesCount === 0) return this; // just one destination.  most common case.\n\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n    if (!dest) dest = state.pipes; // got a match.\n\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  } // slow case. multiple pipe destinations.\n\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, {\n        hasUnpiped: false\n      });\n    }\n\n    return this;\n  } // try to find the right one.\n\n\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n  dest.emit('unpipe', this, unpipeInfo);\n  return this;\n}; // set up data events if they are asked for\n// Ensure readable listeners eventually get something\n\n\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n  var state = this._readableState;\n\n  if (ev === 'data') {\n    // update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused\n\n    if (state.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable', state.length, state.reading);\n\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this);\n      }\n    }\n  }\n\n  return res;\n};\n\nReadable.prototype.addListener = Readable.prototype.on;\n\nReadable.prototype.removeListener = function (ev, fn) {\n  var res = Stream.prototype.removeListener.call(this, ev, fn);\n\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nReadable.prototype.removeAllListeners = function (ev) {\n  var res = Stream.prototype.removeAllListeners.apply(this, arguments);\n\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nfunction updateReadableListening(self) {\n  var state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n\n  if (state.resumeScheduled && !state.paused) {\n    // flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true; // crude way to check if we should resume\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  }\n}\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n} // pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\n\n\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n\n  if (!state.flowing) {\n    debug('resume'); // we flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume()\n\n    state.flowing = !state.readableListening;\n    resume(this, state);\n  }\n\n  state.paused = false;\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  debug('resume', state.reading);\n\n  if (!state.reading) {\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n\n  this._readableState.paused = true;\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n\n  while (state.flowing && stream.read() !== null) {\n    ;\n  }\n} // wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\n\n\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n  stream.on('end', function () {\n    debug('wrapped end');\n\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode\n\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  }); // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function methodWrap(method) {\n        return function methodWrapReturnFunction() {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  } // proxy certain important events.\n\n\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  } // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n\n\n  this._read = function (n) {\n    debug('wrapped _read', n);\n\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nif (typeof Symbol === 'function') {\n  Readable.prototype[Symbol.asyncIterator] = function () {\n    if (createReadableStreamAsyncIterator === undefined) {\n      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');\n    }\n\n    return createReadableStreamAsyncIterator(this);\n  };\n}\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.highWaterMark;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState && this._readableState.buffer;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableFlowing', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.flowing;\n  },\n  set: function set(state) {\n    if (this._readableState) {\n      this._readableState.flowing = state;\n    }\n  }\n}); // exposed for testing purposes only.\n\nReadable._fromList = fromList;\nObject.defineProperty(Readable.prototype, 'readableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.length;\n  }\n}); // Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = state.buffer.consume(n, state.decoder);\n  }\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n  debug('endReadable', state.endEmitted);\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.\n\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n\n    if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well\n      var wState = stream._writableState;\n\n      if (!wState || wState.autoDestroy && wState.finished) {\n        stream.destroy();\n      }\n    }\n  }\n}\n\nif (typeof Symbol === 'function') {\n  Readable.from = function (iterable, opts) {\n    if (from === undefined) {\n      from = require('./internal/streams/from');\n    }\n\n    return from(Readable, iterable, opts);\n  };\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n\n  return -1;\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}